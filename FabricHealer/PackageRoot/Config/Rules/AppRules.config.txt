## Logic rules for Service Fabric Application-level repairs.

## Mitigate Named Arguments - Corresponding data is supplied by FabricObserver, Renamed for brevity by FH.
## | Argument Name             | Definition                                                                                   |
## |---------------------------|----------------------------------------------------------------------------------------------|
## | AppName                   | Name of the SF application, format is fabric:/SomeApp                                        |
## | ServiceName               | Name of the SF service, format is fabric:/SomeApp/SomeService                                |
## | NodeName                  | Name of the node                                                                             | 
## | NodeType                  | Type of node                                                                                 |  
## | PartitionId               | Id of the partition                                                                          |
## | ReplicaOrInstanceId       | Id of the replica or instance                                                                |
## | FOErrorCode               | Error Code emitted by FO (e.g. "FO002")                                                      | 
## | MetricName                | Name of the resource supplied by FO (e.g., CpuPercent or MemoryMB, etc.)                     |   
## | MetricValue               | Corresponding Metric Value supplied by FO (e.g. "85" indicating 85% CPU usage)               | 
## | SystemServiceProcessName  | The name of a Fabric system service process supplied in FO health data                       | 
## | OS                        | The name of the OS from which the FO data was collected (Linux or Windows)                   |

        
## Application-related Metric Names.
## | Name                      |                                                                                    
## |---------------------------|
## | ActiveTcpPorts            |                                         
## | CpuPercent                |    
## | EphemeralPorts            |  
## | EndpointUnreachable*      |    
## | MemoryMB                  | 
## | MemoryPercent             | 
## | FileHandles               | 
## | FileHandlesPercent        | 
## *Network-related repair is not supported today.    

## RunInterval rule: Are we inside the run interval for an app repair? This is optional. It's up to you if you want to employ this type of constraint.
## This below rule means that if any of the repairs for any of the apps in this rule file has run within the past 5 minutes, cut (!), 
## which is a special operator that means, effectively, stop processing rules; do not backtrack.
## By having this as a top level rule, it means no subsequent rules in this file will run if we are inside the run interval.

Mitigate() :- CheckInsideRunInterval(RunInterval=00:10:00), !.

## Mitigation rules for multiple metrics and targets.

## CPU - Percent In Use.

Mitigate(AppName="fabric:/CpuStress", MetricName="CpuPercent") :- TimeScopedRestartCodePackage(20, 01:00:00), !.

## File Handles - Total allocated for Any SF Service Process belonging to the specified SF Application.
## This is example of how to use the Guan system predicate, Contains. It takes two string args, the first is the substring to look for in the second arg. 
## So, arg1 is the needle and arg 2 is the haystack.
## In practice, for this scenario, you would just pass the target app name string into Mitigate, Mitigate(AppName="fabric:/ClusterObserver", ...), for example. 
## Use of the StringContains GuanFunc here is just an example of how to use it. Note that in Prolog, this type of substring matching capability could be expressed as an internal predicate 
## in a much more complex format, in terms of human readability: substring(X,S) :-append(_,T,S), append(X,_,T), X \= []. 
## This is because in Prolog a string is a list of characters. In Guan, a string is just a built-in .NET object, System.String, which already defines a Contains() function. 
## This is one of the great things about Guan: It's .NET all the way down.

## Constrained on AppName, MetricName (FileHandles). 5 repairs within 1 hour window.

Mitigate(AppName=?AppName, MetricName="FileHandles") :- StringContains("ClusterObserver", ?AppName), 
	TimeScopedRestartCodePackage(5, 01:00:00), !.

## Constrained on AppName, MetricName (FileHandles). 5 repairs within 1 hour window.

Mitigate(AppName="fabric:/MyApp", MetricName="FileHandles") :- TimeScopedRestartCodePackage(5, 01:00:00), !.


## Memory - Percent In Use for Any SF Service Process belonging to the specified SF Application. 3 repairs within 10 minute window.

Mitigate(AppName="fabric:/CpuStress", MetricName="MemoryPercent", MetricValue=?MetricValue) :- ?MetricValue >= 30, 
	TimeScopedRestartCodePackage(3, 00:10:00), !.


## Memory - Megabytes In Use for Any SF Service Process belonging to the specified SF Applications. 5 repairs within 5 hour window.

Mitigate(AppName="fabric:/CpuStress", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00), !.
Mitigate(AppName="fabric:/ContainerFoo", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00), !.
Mitigate(AppName="fabric:/ContainerFoo2", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00), !.


## Local Active TCP Ports - Any app service. 5 repairs within 5 hour window. This means if FO warns on Active Ports, then heal. There are no conditional checks (on MetricValue) to take place.

Mitigate(MetricName="ActiveTcpPorts") :- TimeScopedRestartCodePackage(5, 05:00:00), !.


## Local Ephemeral TCP Ports - Any app service. 5 repairs within 5 hour window. This means if FO warns on Ephemeral ports, then heal. There are no conditional checks (on MetricValue) to take place.

Mitigate(MetricName="EphemeralPorts") :- TimeScopedRestartCodePackage(5, 05:00:00), !.


## Ephemeral Ports - Specific Application - any of its services, constrained (conditional check on MetricValue) on number of local ephemeral ports open. 5 repairs within 5 hour window.

Mitigate(AppName="fabric:/MyApp42", MetricName="EphemeralPorts", MetricValue=?MetricValue) :- ?MetricValue > 5000, TimeScopedRestartCodePackage(5, 05:00:00), !.


## TimeScopedRestartCodePackage is an internal predicate to check for the number of times a repair has run to completion within a supplied time window. 
## If Completed Repair count is less then supplied value, then run RestartCodePackage mitigation. If not, emit a message so developer has event data that describes why
## the repair was not attempted at this time. EmitMessage always succeeds. After it runs, cut (don't process any more rules).

TimeScopedRestartCodePackage(?count, ?time) :- GetRepairHistory(?repairCount, TimeWindow=?time), ?repairCount >= ?count,
	EmitMessage("Exhausted specified run count, {0}, within specified max repair time window, {1}. Will not attempt restart code package repair at this time.", ?count, ?time), !.


## If we get here, it means the number of repairs for a target has not exceeded the maximum number specified to run within a time window.
## Note you can add an argument (optional) to RestartCodePackage, name it whatever you want or omit the name, it just has to be a TimeSpan value. 
## This arg represents how long you want to wait to see if the target app service is healed. Internally, FH will check healthstate of repair target after repair execution (with sleeps)
## for a default of 10 minutes for app repair, 30 minutes for a FabricNode repair, and 2 hours for a VM repair. All FH external repair predicates support this optional arg.

TimeScopedRestartCodePackage() :- RestartCodePackage().