## Logic rules for scheduling Machine-level repair jobs in the cluster. EntityType fact is always Machine.
## FH does not conduct (execute) these repairs. It simply schedules them. InfrastructureService is always the Executor for machine-level Repair Jobs.
## You can use the LogRule predicate to have FabricHealer log the rule when Guan is starting to execute it. This is very useful for debugging rules and also
## for rule auditing (so, you can emit telemetry/etw that contains the rule that was running). You can also enable the EnableLogicRuleTracing application parameter 
## in FabricHealer's ApplicationManifest which will log executing rules that contain Repair predicates (the predicates that can lead to some action, like restarting 
## a node or deactivating a node or..).

## Applicable Named Arguments for Mitigate. Facts are supplied by FabricObserver, FHProxy or FH itself.
## Any argument below with (FO/FHProxy) means that only FO or FHProxy will present the fact.
## | Argument Name             | Definition                                                             |
## |---------------------------|------------------------------------------------------------------------|
## | NodeName                  | Name of the node                                                       |
## | NodeType                  | Type of node                                                           |
## | ErrorCode (FO/FHProxy)    | Supported Error Code emitted by caller (e.g. "FO002")                  |
## | MetricName (FO/FHProxy)   | Name of the Metric  (e.g., CpuPercent or MemoryMB, etc.)               |
## | MetricValue (FO/FHProxy)  | Corresponding Metric Value (e.g. "85" indicating 85% CPU usage)        |
## | OS                        | The name of the OS where FabricHealer is running (Linux or Windows)    |
## | HealthState               | The HealthState of the target entity: Error or Warning                 |
## | Source                    | The Source ID of the related SF Health Event                           |
## | Property                  | The Property of the related SF Health Event                            |

## Metric Names, from FO or FHProxy.
## | Name                           |                                           
## |--------------------------------|
## | ActiveTcpPorts                 |                  
## | CpuPercent                     |
## | EphemeralPorts                 |
## | EphemeralPortsPercent          |
## | MemoryMB                       |
## | MemoryPercent                  |
## | Handles (Linux-only)           |
## | HandlesPercent (Linux-only)    |


## The logic program below is a repair specification (policy) that does not require facts from FabricObserver (FO) or FHProxy.
## It demonstrates a series of constraints and repair scheduling escalations.

## Don't proceed if the target entity is not in Error.
Mitigate(HealthState=?healthState) :- not(?healthState == Error), !.

## Don't proceed unless the specified watchdog created the Error health event.
##Mitigate(Source=?source) :- not(match(?source, "EventLogWatchdog")), !.

## Don't proceed if there are already 2 or more machine repairs currently active in the cluster.
Mitigate() :- CheckOutstandingRepairs(2), !.

## Don't proceed if FH scheduled a machine repair less than 10 minutes ago.
Mitigate() :- CheckInsideScheduleInterval(00:10:00), !.

## Don't proceed if target node is currently inside a post-repair health probation period (post-repair means a Completed repair; target node is still recovering).
Mitigate() :- CheckInsideNodeProbationPeriod(00:30:00), !.

## Don't proceed if the target node hasn't been in Error (including cyclic Up/Down) state for at least two hours.
Mitigate() :- CheckInsideHealthStateMinDuration(02:00:00), !.

## For certain environments, the correct mitigation is to deactivate the target node. The below rule schedules a node deactivation
## (Here, the node impact level is RemoveData, but you can supply RestartNode or RemoveNode depending on your intention). If you do not specify an ImpactLevel,
## the default level used will be RestartNode.
##Mitigate(Source=?source, Property=?property) :- LogRule(59), match(?source, "EventLogWatchdog"), match(?property, "CriticalMachineFailure"),
##	DeactivateFabricNode(ImpactLevel=RemoveData).

## If you employ multiple rules with the same repair predicate (e.g., DeactivateFabricNode(ImpactLevel=RemoveData)) and want FH to log them, 
## then you must add the LogRule([LineNumber]) predicate to each rule in order for FabricHealer to trace correctly, regardless of EnableLogicRuleTracing setting. 
## Please see the Debugging/Auditing Rules section in Using.md to learn more.
##Mitigate(Source=?source, Property=?property) :- LogRule(65), match(?source, "SomeOtherWatchdog"), match(?property, "SomeOtherFailure"),
##	DeactivateFabricNode(ImpactLevel=RemoveData).

## Infra Mitigations (RM repair scheduling logic - InfrastructureService for the target node type will be the repair Executor, not FH).
## The logic below demonstrates how to specify a repair escalation path: Reboot -> Reimage -> Heal -> Triage (human intervention required).
## ScheduleMachineRepair predicate takes any repair action string. There are a handful that are supported by RepairManager/InfrastructureService, like below.

## Reboot.
## Don't process any other rules if scheduling succeeds OR fails (note the position of ! (cut operator)) and there are less than 1 of these repairs that have completed in the last 8 hours.
Mitigate() :- GetRepairHistory(?repairCount, 08:00:00, System.Reboot), ?repairCount < 1, !, ScheduleMachineRepair(System.Reboot).

## ReimageOS escalation. *This is not supported in VMSS-managed clusters*.
Mitigate() :- GetRepairHistory(?repairCount, 08:00:00, System.ReimageOS), ?repairCount < 1, !, ScheduleMachineRepair(System.ReimageOS).

## Azure.Heal escalation.
Mitigate() :- GetRepairHistory(?repairCount, 08:00:00, System.Azure.Heal), ?repairCount < 1, !, ScheduleMachineRepair(System.Azure.Heal).

## Triage escalation.
## If we end up here, then human intervention is required. LogInfo will generate ETW/Telemetry/Health events containing the message.
## FabricHealer will also schedule a ManualTriageNeeded repair task. Once you manually solve the problem, then cancel this repair task as it will block FabricHealer
## from scheduling any other machine repairs for the target node until canceled. It also counts against the number of concurrent Active repairs you specified
## above in the CheckOutstandingRepairs predicate.
Mitigate(NodeName=?nodeName) :- LogInfo("0042_{0}: Specified Machine repair escalations have been exhausted for node {0}. Human intervention is required.", ?nodeName), 
	ScheduleMachineRepair(ManualTriageNeeded).