## Logic rules for scheduling Machine-level repair jobs in the cluster. Only OS reboot is supported today for VMSS-managed clusters. 
## FH does not conduct (execute) these repairs. It simply schedules them. InfrastructureService is always the Executor for these types of Repair Jobs.

## Applicable Named Arguments for Mitigate. Facts are supplied by FabricObserver, FHProxy or FH itself.
## Any argument below with (FO/FHProxy) means that only FO or FHProxy will present the fact.
## | Argument Name             | Definition                                                             |
## |---------------------------|------------------------------------------------------------------------|
## | NodeName                  | Name of the node                                                       | 
## | NodeType                  | Type of node                                                           |  
## | ErrorCode (FO/FHProxy)    | Supported Error Code emitted by caller (e.g. "FO002")                  | 
## | MetricName (FO/FHProxy)   | Name of the Metric  (e.g., CpuPercent or MemoryMB, etc.)               |   
## | MetricValue (FO/FHProxy)  | Corresponding Metric Value (e.g. "85" indicating 85% CPU usage)        | 
## | OS                        | The name of the OS from which the data was collected (Linux or Windows)|
## | HealthState               | The HealthState of the target entity: Error or Warning                 |
    
## Metric Names, from FO or FHProxy.
## | Name                           |                                                                                    
## |--------------------------------|
## | ActiveTcpPorts                 |                                         
## | CpuPercent                     |    
## | EphemeralPorts                 | 
## | EphemeralPortsPercent          | 
## | MemoryMB                       | 
## | MemoryPercent                  | 
## | FileHandles (Linux-only)       | 
## | FileHandlesPercent (Linux-only)| 

## Supported infrastructure repair action names.
## These are supplied to RM with IS as executor.
## | Name                                      |
## |-------------------------------------------|
## | System.Reboot                             |
## | System.ReimageOS                          |
## | System.FullReimage                        |

## If this is what you need, then first check if we are inside the specified run interval for scheduling *any* machine-level repair for any reason. 
## Ending with a cut (!) means the goal (Mitigate) has been satisfied and Guan will immediately stop processing rules.
## Mitigate() :- CheckInsideRunInterval(02:00:00), !.

## TimeScopedScheduleReboot is an internal predicate to check for the number of times a Machine reboot repair has run to completion within a supplied time window. 
## If Completed Machine Repair count is less then supplied value, then schedule an infrastructure repair via ScheduleMachineRepair predicate.
TimeScopedScheduleReboot(?count, ?time) :- GetRepairHistory(?repairCount, ?time), ?repairCount < ?count, 
  ScheduleMachineRepair("System.Reboot", MaxOutstandingRepairs=2, ProbationWaitDurationPost=00:30:00).

## Metric-defined machine repair scheduling.

## Percent Memory in Use (of total physical).
Mitigate(MetricName=MemoryPercent, MetricValue=?MetricValue) :- ?MetricValue >= 95,
  GetHealthEventHistory(?HealthEventCount, 00:15:00), ?HealthEventCount >= 3,
  TimeScopedScheduleReboot(4, 08:00:00).

## File Handles/FDs. Linux-only.

## Percent Allocated, System-wide.
Mitigate(MetricName=FileHandlesPercent, MetricValue=?MetricValue, OS=Linux) :- ?MetricValue >= 95,
  GetHealthEventHistory(?HealthEventCount, 00:15:00), ?HealthEventCount >= 3,
  TimeScopedScheduleReboot(2, 08:00:00).

## Total Allocated, System-wide.
Mitigate(MetricName=FileHandles, MetricValue=?MetricValue, OS=Linux) :- ?MetricValue >= 1000000,
  GetHealthEventHistory(?HealthEventCount, 00:15:00), ?HealthEventCount >= 3,
  TimeScopedScheduleReboot(2, 08:00:00).

## Non-Metric-defined machine repair scheduling. This means FH will have done the work to figure out if some node is in Error (doesn't matter if FO or FHProxy generated the health event).
## So, in the below set of logic rules, the idea is if some node is in Error, try and repair it via 1. Reboot or 2. Reimage (if Reboot doesn't work) or 3. Heal (if Reimage doesn't work).

## Don't schedule any machine repair if one was scheduled less than 10 minutes ago. If this rule succeeds, Guan will immediately stop processing rules (! to make it explicit).
Mitigate() :- CheckInsideScheduleInterval(00:10:00), !.

## Top level rule for post-probation check. FH knows the target node and other repair facts before this rule is executed. So, if any successful machine repair for the target node 
## is still in post-repair probation (specified as 30 minutes below, which means 30 minutes after the related SF repair job completed, according to RM.
Mitigate() :- CheckInsideProbationPeriod(00:30:00), !.

## If target node is not in Error, then cut.
Mitigate(HealthState=?healthState) :- not(?healthState == Error), !.

## TODO: Work on this... Have to account for up/down node states. This will require state.
## ProbationWaitDurationPre (minimum time-in-error) rule. If this rule succeeds, Guan will immediately stop processing rules.
Mitigate() :- GetEntityHealthStateDuration(?duration, Entity=Machine, HealthState=Error), ?duration <= 02:00:00, !.

## TODO: MaxOutstandingRepairs should be pulled out and made a predicate, CheckOutstandingRepairs(MaxRepairs=2), !...
## Reboot. (Supported in VMSS-managed clusters.)
Mitigate() :- GetRepairHistory(?repairCount, 04:00:00, "System.Reboot"), ?repairCount < 2, ScheduleMachineRepair("System.Reboot", MaxOutstandingRepairs=2).

## Escalations.

## Reimage. (Not supported in VMSS-managed clusters.)
Mitigate(HealthState=Error) :- GetRepairHistory(?repairCount, 04:00:00, "System.Reboot"), ?repairCount >= 2, ScheduleMachineRepair("System.ReimageOS", MaxOutstandingRepairs=2).

## Heal. (Supported in VMSS-managed clusters.)
Mitigate() :- GetRepairHistory(?repairCount, 04:00:00, "System.ReimageOS"), ?repairCount >= 2, ScheduleMachineRepair("System.Azure.Heal", MaxOutstandingRepairs=2).

## If we end up here, then human intervention is required (Triage).