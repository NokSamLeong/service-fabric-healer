## Logic rules for scheduling Machine-level repair jobs in the cluster. EntityType fact is always Machine.
## FH does not conduct (execute) these repairs. It simply schedules them. InfrastructureService is always the Executor for machine-level Repair Jobs.
## You can use the LogRule predicate to have FabricHealer log the rule when Guan is starting to execute it. This is very useful for debugging rules and also
## for rule auditing (so, you can emit telemetry/etw that contains the rule that was running). You can also enable the EnableLogicRuleTracing application parameter 
## in FabricHealer's ApplicationManifest which will log executing rules that contain Repair predicates (the predicates that can lead to some action, like restarting 
## a node or deactivating a node or..).

## Applicable Named Arguments for Mitigate. Facts are supplied by FabricObserver, FHProxy or FH itself.
## Any argument below with (FO/FHProxy) means that only FO or FHProxy will present the fact.
## | Argument Name             | Definition                                                             |
## |---------------------------|------------------------------------------------------------------------|
## | NodeName                  | Name of the node                                                       |
## | NodeType                  | Type of node                                                           |
## | ErrorCode (FO/FHProxy)    | Supported Error Code emitted by caller (e.g. "FO002")                  |
## | MetricName (FO/FHProxy)   | Name of the Metric  (e.g., CpuPercent or MemoryMB, etc.)               |
## | MetricValue (FO/FHProxy)  | Corresponding Metric Value (e.g. "85" indicating 85% CPU usage)        |
## | OS                        | The name of the OS where FabricHealer is running (Linux or Windows)    |
## | HealthState               | The HealthState of the target entity: Error or Warning                 |
## | Source                    | The Source ID of the related SF Health Event                           |
## | Property                  | The Property of the related SF Health Event                            |

## Metric Names, from FO or FHProxy.
## | Name                           |                                           
## |--------------------------------|
## | ActiveTcpPorts                 |                  
## | CpuPercent                     |
## | EphemeralPorts                 |
## | EphemeralPortsPercent          |
## | MemoryMB                       |
## | MemoryPercent                  |
## | Handles (Linux-only)           |
## | HandlesPercent (Linux-only)    |


## Don't proceed if the target entity is not in Error.
Mitigate(HealthState=?healthState) :- LogRule(36), not(?healthState == Error), !.

## Don't proceed unless a specific watchdog, EventLogWatchdog, put the Fabric node into Error state. You don't need
## to check for this again as this is a top level constraint.
##Mitigate(Source=?source) :- LogRule(40), Empty(?source), !.
##Mitigate(Source=?source) :- LogRule(41), notmatch(?source, "EventLogWatchdog"), !.

## Don't proceed if there are already 2 or more machine repairs currently active in the cluster.
Mitigate :- LogRule(44), CheckOutstandingRepairs(2), !.

## Don't proceed if FH scheduled a machine repair less than 10 minutes ago.
Mitigate :- LogRule(47), CheckInsideScheduleInterval(00:10:00), !.

## Don't proceed if target machine is currently in recovery probation.
Mitigate :- LogRule(50), CheckInsideNodeProbationPeriod(00:30:00), !.

## Don't proceed if the target node hasn't been in Error (including cyclic Up/Down) state for at least two hours.
##Mitigate :- LogRule(53), CheckInsideHealthStateMinDuration(02:00:00), !.

## Don't proceed if the required facts are not present.
##Mitigate(Property=?property) :- LogRule(56), Empty(?property), !.

## Repairs.
##Mitigate(Source=?source, Property=?property) :- LogRule(59), match(?property, "CriticalMachineFailure"), match(?property, "1"),
	##GetHealthEventHistory(?count, 00:30:00), ?count >= 3,
	##GetRepairHistory(?repairCount, 08:00:00, DeactivateFabricNode),
	##?repairCount < 1, !, DeactivateFabricNode(MaxDuration=00:02:00).

##Mitigate(Source=?source, Property=?property) :- LogRule(64), match(?property, "Ntfs"), match(?property, "55"),
	##GetHealthEventHistory(?count, 00:30:00), ?count >= 3,
	##GetRepairHistory(?repairCount, 08:00:00, DeactivateFabricNode),
	##?repairCount < 1, !, DeactivateFabricNode(MaxDuration=08:00:00).

##Mitigate(Source=?source, Property=?property) :- LogRule(69), match(?property, "CriticalMachineFailure"), match(?property, "2"),
    ##GetHealthEventHistory(?count, 00:30:00),
	##?count >= 3, GetRepairHistory(?repairCount, 08:00:00, System.Reboot),
	##?repairCount < 1, !, ScheduleMachineRepair(System.Reboot).


## Infra Mitigations (RM repair scheduling logic - InfrastructureService for the target node type will be the repair Executor, not FH).
## The logic below demonstrates how to specify a repair escalation path: Reboot -> Reimage -> Heal -> Triage (human intervention required).
## ScheduleMachineRepair predicate takes any repair action string. There are a handful that are supported by RepairManager/InfrastructureService, like below.

## Reboot.
## Don't process any other rules if scheduling succeeds OR fails (note the position of ! (cut operator)) and there are less than 1 of these repairs that have completed in the last 8 hours.
Mitigate :- GetRepairHistory(?repairCount, 08:00:00, System.Reboot), ?repairCount < 1, !, ScheduleMachineRepair(System.Reboot).

## ReimageOS escalation. *This is not supported in VMSS-managed clusters*.
Mitigate :- GetRepairHistory(?repairCount, 08:00:00, System.ReimageOS), ?repairCount < 1, !, ScheduleMachineRepair(System.ReimageOS).

## Azure.Heal escalation.
Mitigate :- GetRepairHistory(?repairCount, 08:00:00, System.Azure.Heal), ?repairCount < 1, !, ScheduleMachineRepair(System.Azure.Heal).

## Triage escalation.
## If we end up here, then human intervention is required. LogInfo will generate ETW/Telemetry/Health events containing the message.
## FabricHealer will also schedule a ManualTriageNeeded repair task. Once you manually solve the problem, then cancel this repair task as it will block FabricHealer
## from scheduling any other machine repairs for the target node until canceled. It also counts against the number of concurrent Active repairs you specified
## above in the CheckOutstandingRepairs predicate.
Mitigate(NodeName=?nodeName) :- LogInfo("0042_{0}: Specified Machine repair escalations have been exhausted for node {0}. Human intervention is required.", ?nodeName), 
	ScheduleMachineRepair(ManualTriageNeeded).