## Logic rules for Service Fabric Application-level repairs.

## Mitigate (the goal, Guan.CompoundTerm type) Named Arguments (CompoundTerm Arguments (of type Guan.Constant)) - Corresponding data is supplied by FabricObserver, renamed for brevity by FH.
## | Argument Name             | Definition                                                                                   |
## |---------------------------|----------------------------------------------------------------------------------------------|
## | AppName                   | Name of the SF application, format is fabric:/SomeApp                                        |
## | ServiceName               | Name of the SF service, format is fabric:/SomeApp/SomeService                                |
## | NodeName                  | Name of the node                                                                             | 
## | NodeType                  | Type of node                                                                                 |  
## | PartitionId               | Id of the partition                                                                          |
## | ReplicaOrInstanceId       | Id of the replica or instance                                                                |
## | FOErrorCode               | Error Code emitted by FO (e.g. "FO002")                                                      | 
## | MetricName                | Name of the resource supplied by FO (e.g., CpuPercent or MemoryMB, etc.)                     |   
## | MetricValue               | Corresponding Metric Value supplied by FO (e.g. "85" indicating 85% CPU usage)               | 
## | SystemServiceProcessName  | The name of a Fabric system service process supplied in FO health data                       | 
## | OS                        | The name of the OS from which the FO data was collected (Linux or Windows)                   |

        
## Application-related Metric Names.
## | Name                      |                                                                                    
## |---------------------------|
## | ActiveTcpPorts            |                                         
## | CpuPercent                |    
## | EphemeralPorts            |  
## | EndpointUnreachable*      |    
## | MemoryMB                  | 
## | MemoryPercent             | 
## | FileHandles               | 
## | FileHandlesPercent        | 
## *Network-related repair is not supported today.    

## RunInterval rule: Are we inside the run interval for an app repair? This is optional. It's up to you if you want to employ this type of constraint.
## This below rule means that if any of the repairs for any of the apps in this rule file has run within the past 10 minutes, cut (!), 
## which is a special operator that means, effectively, stop processing rules; do not backtrack.
## By having this as a top level rule, it means no subsequent rules in this file will run if we are inside the specified run interval.

## Mitigate() :- CheckInsideRunInterval(RunInterval=00:30:00), !.


## Mitigation rules for multiple metrics and targets.

## CPU - Percent In Use - Constrained on AppName and number of times FabricObserver generates an Error/Warning Health report for CpuPercent metric within a specified timespan.
## This reads: Try to mitigate an SF Application in Error or Warning named fabric:/CpuStress where one of its services is consuming too much CPU (as a percentage of total CPU) 
## and where at least 3 health events identifying this problem were produced in the last 15 minutes. This is useful to ensure you don't mitigate a transient (short-lived)
## problem as they will self-correct.

Mitigate(AppName="fabric:/CpuStress", MetricName="CpuPercent", MetricValue=?MetricValue) :- ?MetricValue >= 15,
	GetHealthEventHistory(?HealthEventCount, TimeRange=00:15:00),
	?HealthEventCount >= 3,
	TimeScopedRestartCodePackage(4, 01:00:00).


## CPU - Percent In Use - Constrained on AppName = "fabric:/MyApp42", observed Metric value and health event count within specified time range.

Mitigate(AppName="fabric:/MyApp42", MetricName="CpuPercent", MetricValue=?MetricValue) :- ?MetricValue >= 80, 
	GetHealthEventHistory(?HealthEventCount, TimeRange=00:15:00),
	?HealthEventCount >= 3,
	TimeScopedRestartCodePackage(4, 01:00:00).


## CPU - Percent In Use - Specific application, any of its service processes. Your FO error/warning threshold alone prompts repair. This doesn't take into account transient misbehavior.

Mitigate(AppName="fabric:/MyApp", MetricName="CpuPercent") :- TimeScopedRestartCodePackage(5, 01:00:00).


## CPU - Percent In Use - Any application's service that exceeds 90% cpu usage, repair up to 5 times in a one hour window.

Mitigate(MetricName="CpuPercent", MetricValue=?MetricValue) :- ?MetricValue >= 90, TimeScopedRestartCodePackage(5, 01:00:00).

## File Handles - Total allocated for Any SF Service Process belonging to the specified SF Application.
## This is example of how to use the Guan system predicate, Contains. It takes two string args, the first is the substring to look for in the second arg. 
## So, arg1 is the needle and arg 2 is the haystack.
## In practice, for this scenario, you would just pass the target app name string into Mitigate, Mitigate(AppName="fabric:/ClusterObserver", ...), for example. 
## Use of the StringContains GuanFunc here is just an example of how to use it. Note that in Prolog, this type of substring matching capability could be expressed as an internal predicate 
## in a much more complex format, in terms of human readability: substring(X,S) :-append(_,T,S), append(X,_,T), X \= []. 
## This is because in Prolog a string is a list of characters. In Guan, a string is just a built-in .NET object, System.String, which already defines a Contains() function. 
## This is one of the great things about Guan: It's .NET all the way down.

## Constrained on AppName, MetricName (FileHandles). 5 repairs within 1 hour window.

Mitigate(AppName=?AppName, MetricName="FileHandles") :- StringContains("ClusterObserver", ?AppName), 
	TimeScopedRestartCodePackage(5, 01:00:00).


## Constrained on AppName, MetricName (FileHandles). 5 repairs within 1 hour window.

Mitigate(AppName="fabric:/MyApp", MetricName="FileHandles") :- TimeScopedRestartCodePackage(5, 01:00:00).


## Memory - Percent In Use for Any SF Service Process belonging to the specified SF Application. 3 repairs within 10 minute window.

Mitigate(AppName="fabric:/CpuStress", MetricName="MemoryPercent", MetricValue=?MetricValue) :- ?MetricValue >= 30, 
	TimeScopedRestartCodePackage(3, 00:10:00).


## Memory - Megabytes In Use for Any SF Service Process belonging to the specified SF Applications. 5 repairs within 5 hour window.

Mitigate(AppName="fabric:/CpuStress", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00).
Mitigate(AppName="fabric:/ContainerFoo", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00).
Mitigate(AppName="fabric:/ContainerFoo2", MetricName="MemoryMB") :- TimeScopedRestartCodePackage(5, 05:00:00).


## Local Active TCP Ports - Any app service. 5 repairs within 5 hour window. This means if FO warns on Active Ports, then heal. There are no conditional checks (on MetricValue) to take place.

Mitigate(MetricName="ActiveTcpPorts") :- TimeScopedRestartCodePackage(5, 05:00:00).


## Ephemeral Ports - Specific Application: any of its services, constrained on number of local ephemeral ports open. 
## 5 repairs within 5 hour window.

Mitigate(AppName="fabric:/MyApp42", MetricName="EphemeralPorts", MetricValue=?MetricValue) :- ?MetricValue > 5000, TimeScopedRestartCodePackage(5, 05:00:00).


## Ephemeral TCP Ports - Any app service. 5 repairs within 5 hour window. This means if FO warns on Ephemeral ports usage, then heal. 
## There are no conditional checks.

Mitigate(MetricName="EphemeralPorts") :- TimeScopedRestartCodePackage(5, 05:00:00).


## TimeScopedRestartCodePackage is an internal predicate to check for the number of times a repair has run to completion within a supplied time window. 
## If Completed Repair count is less then supplied value, then run RestartCodePackage mitigation. If not, emit a message so developer has event data that describes why
## the repair was not attempted at this time. EmitMessage always succeeds.

TimeScopedRestartCodePackage(?count, ?time) :- GetRepairHistory(?repairCount, TimeWindow=?time), ?repairCount >= ?count,
	EmitMessage("Exhausted specified run count, {0}, within specified max repair time window, {1}. Will not attempt restart code package repair at this time.", ?count, ?time).


## If we get here, it means the number of repairs for a target has not exceeded the maximum number specified to run within a time window.
## Note you can add up to two optional arguments to RestartCodePackage, name them whatever you want or omit the names, it just has to be either a TimeSpan value for how long to wait 
## for the repair target to become healthy and/or a bool for whether or not RM should do health checks before and after the repair executes. 
## See below for an example using both optional arguments (arguments are named for clarity (generally a good idea)...you could also supply RestartCodePackage(true, 00:10:00)).

TimeScopedRestartCodePackage() :- RestartCodePackage(DoHealthChecks=true, MaxWaitTimeForHealthStateOk=00:10:00).